// ============================================================
// UiToAi - Exporter (Run -> folder files)
// ============================================================

function sanitizeFilename(s) {
  return String(s || "")
    .replace(/[\\/:*?"<>|]/g, "-")
    .replace(/\s+/g, "_")
    .slice(0, 60);
}

function t(key, substitutions) {
  try {
    const msg = chrome?.i18n?.getMessage?.(key, substitutions);
    return msg || "";
  } catch {
    return "";
  }
}

function safeJoin(list, sep) {
  if (!Array.isArray(list) || list.length === 0) return "";
  return list.filter(Boolean).join(sep);
}

function firstNValues(topList, n) {
  if (!Array.isArray(topList)) return [];
  return topList.slice(0, n).map((x) => x?.value).filter(Boolean);
}

function summarizeFocusRing(focusRules) {
  if (!Array.isArray(focusRules) || focusRules.length === 0) return null;
  const first = focusRules[0];
  if (!first) return null;
  const selector = String(first.selector || "");
  const summary = String(first.declarationsSummary || "");
  if (!selector && !summary) return null;
  return {
    count: focusRules.length,
    exampleSelector: selector,
    exampleDeclarations: summary
  };
}

function buildElementsExport(run, project) {
  const spec = run?.spec || {};
  const host = spec?.target?.host || project?.host || "unknown";
  const createdAt = spec?.target?.capturedAt || new Date().toISOString();

  const componentCatalog = spec?.componentCatalog || {};
  const picked = run?.samples?.elements || [];

  return {
    version: 1,
    generatedAt: new Date().toISOString(),
    target: {
      host,
      url: spec?.target?.url || run?.url || "",
      title: spec?.target?.title || run?.title || "",
      capturedAt: createdAt
    },
    componentCatalog: {
      components: componentCatalog.components || [],
      componentsSources: componentCatalog.componentsSources || null
    },
    pickedElements: picked
  };
}

function generatePromptMd(spec, project) {
  const host = spec?.target?.host || project?.host || "unknown";
  const createdAt = spec?.target?.capturedAt || new Date().toISOString();

  const settings = spec?.engineeringFingerprint?.cssArchitectureHints?.settings || {};
  const denoise = settings?.denoise === undefined ? true : Boolean(settings.denoise);
  const sanitize = Boolean(settings?.sanitize);
  const maxElements = Number.isFinite(settings?.maxElements) ? settings.maxElements : null;
  const maxRules = Number.isFinite(settings?.maxRules) ? settings.maxRules : null;
  const truncateLength = Number.isFinite(settings?.truncateLength) ? settings.truncateLength : null;

  const lines = [
    t("promptTitle", [host]) || `# Design System Extraction: ${host}`,
    "",
    t("promptGenerated", [createdAt]) || `> Generated by UiToAi at ${createdAt}`,
    "",
    "## Goal",
    "Recreate the UI of the target website with **high fidelity** (tokens, layout rules, motion, a11y, component states).",
    "",
    t("promptInstructionsTitle") || "## Instructions for AI",
    "",
    t("promptInstructionsLine") || "Use this spec to replicate the design system. Follow this order:",
    "",
    t("promptStep1") || "1. **Design Tokens** - Set up colors, typography, spacing, shadows from `spec.designTokens`",
    t("promptStep2") || "2. **Layout** - Configure breakpoints and container widths from `spec.layoutRules`",
    t("promptStep3") || "3. **Motion** - Apply transition/animation timings from `spec.motionSpec`",
    t("promptStep4") || "4. **Accessibility** - Ensure focus rings and ARIA patterns from `spec.a11ySpec`",
    t("promptStep5") || "5. **Components** - Build components matching the catalog patterns",
    "",
    "## Constraints",
    "- Use the extracted tokens (colors/typography/spacing/radius/shadow) consistently; avoid inventing new values.",
    "- Respect responsive breakpoints and container widths (mobile-first).",
    "- Implement interaction states: hover/active/focus-visible/disabled based on `spec.componentCatalog.stateRules`.",
    "- Keep accessibility: keyboard focus rings + ARIA patterns.",
    "",
    "### Collection Settings (for reference)",
    `- sanitize: ${sanitize}`,
    `- denoise: ${denoise}`,
    (maxElements !== null ? `- maxElements: ${maxElements}` : "- maxElements: (default)"),
    (maxRules !== null ? `- maxRules: ${maxRules}` : "- maxRules: (default)"),
    (truncateLength !== null ? `- truncateLength: ${truncateLength}` : "- truncateLength: (default)"),
    "",
    t("promptKeyValues") || "## Key Values",
    ""
  ];

  // Colors
  const colors = spec?.designTokens?.colors?.top || [];
  if (colors.length > 0) {
    lines.push("### Colors (Top " + colors.length + ")");
    colors.slice(0, 8).forEach((c) => {
      lines.push(`- \`${c.value}\` (${c.count} occurrences)`);
    });
    lines.push("");
  }

  // Typography
  const fonts = spec?.designTokens?.typography?.fontFamiliesTop || [];
  if (fonts.length > 0) {
    lines.push("### Font Families");
    fonts.slice(0, 5).forEach((f) => {
      lines.push(`- \`${f.value}\` (${f.count})`);
    });
    const fontSizes = firstNValues(spec?.designTokens?.typography?.scale?.fontSizeTop || [], 8);
    if (fontSizes.length) {
      lines.push(`- Suggested font-size scale: ${safeJoin(fontSizes, ", ")}`);
    }
    lines.push("");
  }

  // Spacing / radius / shadow
  const spacing = firstNValues(spec?.designTokens?.spacing?.distribution || [], 8);
  const radius = firstNValues(spec?.designTokens?.radius?.distribution || [], 8);
  const shadow = firstNValues(spec?.designTokens?.shadow?.distribution || [], 5);
  if (spacing.length) {
    lines.push("### Spacing (Top)");
    lines.push(`- ${safeJoin(spacing, ", ")}`);
    lines.push("");
  }
  if (radius.length) {
    lines.push("### Radius (Top)");
    lines.push(`- ${safeJoin(radius, ", ")}`);
    lines.push("");
  }
  if (shadow.length) {
    lines.push("### Shadows (Top)");
    shadow.forEach((v) => lines.push(`- \`${v}\``));
    lines.push("");
  }

  // Breakpoints
  const breakpoints = spec?.layoutRules?.breakpoints?.candidates || [];
  if (breakpoints.length > 0) {
    lines.push("### Breakpoints");
    lines.push(`- ${breakpoints.join("px, ")}px`);
    lines.push("");
  }

  const containers = spec?.layoutRules?.containers || {};
  const maxWidthTop = containers?.maxWidthTop || [];
  if (Array.isArray(maxWidthTop) && maxWidthTop.length > 0) {
    lines.push("### Containers");
    lines.push("- max-width candidates (top):");
    maxWidthTop.slice(0, 6).forEach((x) => lines.push(`  - \`${x.value}\` (${x.count})`));
    lines.push("");
  }

  // Framework hints
  const fw = spec?.engineeringFingerprint?.frameworkHints || {};
  const detected = Object.entries(fw)
    .filter(([k, v]) => v && k !== "unknown")
    .map(([k]) => k);
  if (detected.length > 0) {
    lines.push("### Detected Frameworks");
    lines.push(`- ${detected.join(", ")}`);
    lines.push("");
  }

  // Motion
  const transitions = spec?.motionSpec?.transitions?.durationTop || [];
  if (transitions.length > 0) {
    lines.push("### Transition Durations");
    transitions.slice(0, 5).forEach((t) => {
      lines.push(`- \`${t.value}\` (${t.count})`);
    });
    lines.push("");
  }

  const easings = spec?.motionSpec?.transitions?.easingTop || [];
  if (Array.isArray(easings) && easings.length > 0) {
    lines.push("### Transition Easings");
    easings.slice(0, 5).forEach((e) => lines.push(`- \`${e.value}\` (${e.count})`));
    lines.push("");
  }

  const keyframes = spec?.motionSpec?.keyframes?.namesTop || [];
  if (Array.isArray(keyframes) && keyframes.length > 0) {
    lines.push("### Keyframes (names)");
    lines.push(`- ${safeJoin(keyframes.slice(0, 16), ", ")}`);
    lines.push("");
  }

  // A11y focus ring
  const focusSummary = summarizeFocusRing(spec?.a11ySpec?.focusRingRules || []);
  if (focusSummary) {
    lines.push("### Focus Ring");
    lines.push(`- rules captured: ${focusSummary.count}`);
    if (focusSummary.exampleSelector) lines.push(`- example selector: \`${focusSummary.exampleSelector}\``);
    if (focusSummary.exampleDeclarations) lines.push(`- example declarations: \`${focusSummary.exampleDeclarations}\``);
    lines.push("");
  }

  // Components & state rules
  const compTypes = (spec?.componentCatalog?.components || []).map((c) => c?.type).filter(Boolean);
  if (compTypes.length) {
    lines.push("### Component Catalog");
    lines.push(`- component types: ${safeJoin(compTypes, ", ")}`);
    lines.push("");
  }

  const stateRulesCount = Array.isArray(spec?.componentCatalog?.stateRules) ? spec.componentCatalog.stateRules.length : 0;
  if (stateRulesCount > 0) {
    const stats = spec?.componentCatalog?.stateRulesStats || {};
    lines.push("### State Rules (:hover/:active/:focus/:disabled)");
    lines.push(`- rules captured: ${stateRulesCount}`);
    if (stats?.pseudoOccurrences) {
      const p = stats.pseudoOccurrences;
      lines.push(`- pseudo occurrences: hover=${p.hover || 0}, active=${p.active || 0}, focus=${p.focus || 0}, focus-visible=${p.focusVisible || 0}, disabled=${p.disabled || 0}`);
    }
    lines.push("");
  }

  lines.push("## Acceptance Criteria");
  lines.push("- Token fidelity: main colors/font families/spacing/radius match the extracted top values.");
  lines.push("- Responsive fidelity: breakpoints + container widths behave similarly.");
  lines.push("- State fidelity: hover/active/focus-visible/disabled match captured state rules.");
  lines.push("- A11y fidelity: visible focus ring and correct ARIA roles/attributes where applicable.");
  lines.push("");

  lines.push(t("promptFilesIncluded") || "## Files Included");
  lines.push("");
  lines.push(t("promptFileSpec") || "- `ai/spec.json` - Full specification data");
  lines.push(t("promptFilePrompt") || "- `ai/prompt.md` - This file");
  lines.push(t("promptFileSamples") || "- `samples/elements.json` - Captured element samples");
  lines.push("");
  lines.push("---");
  lines.push(t("promptFooter") || "*Use spec.json as the source of truth for all design decisions.*");

  return lines.join("\n");
}

async function downloadFile(folder, relativePath, content, mimeType) {
  // MV3 Service Worker 环境中 URL.createObjectURL 可能不可用。
  // 对于文本类导出（JSON/Markdown），用 data: URL 更稳定。
  const url = `data:${mimeType};charset=utf-8,${encodeURIComponent(String(content ?? ""))}`;

  try {
    // 所有文件都不弹出保存对话框，直接下载到默认下载目录
    await chrome.downloads.download({
      url,
      filename: `${folder}/${relativePath}`,
      saveAs: false // 统一不弹窗
    });
    return { ok: true, path: relativePath };
  } catch (err) {
    return { ok: false, path: relativePath, error: String(err?.message || err) };
  }
}

export async function exportRunToFiles(run, project) {
  const spec = run?.spec || {};
  const samples = run?.samples || { elements: [] };

  const host = sanitizeFilename(spec?.target?.host || project?.host || "unknown");
  const stamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
  const folder = `UiToAi-export-${host}-${stamp}`;

  const results = [];
  const startTime = Date.now();

  // 并行下载所有文件，提高效率
  const downloadPromises = [
    // 1. ai/spec.json
    downloadFile(
      folder,
      "ai/spec.json",
      JSON.stringify(spec, null, 2),
      "application/json"
    ),
    // 2. ai/prompt.md
    downloadFile(
      folder,
      "ai/prompt.md",
      generatePromptMd(spec, project),
      "text/markdown"
    ),
    // 3. samples/elements.json
    downloadFile(
      folder,
      "samples/elements.json",
      JSON.stringify(buildElementsExport(run, project), null, 2),
      "application/json"
    )
  ];

  // 等待所有下载完成
  const downloadResults = await Promise.allSettled(downloadPromises);

  // 处理结果
  downloadResults.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      results.push(result.value);
    } else {
      const fileName = ['ai/spec.json', 'ai/prompt.md', 'samples/elements.json'][index];
      results.push({
        ok: false,
        path: fileName,
        error: String(result.reason?.message || result.reason)
      });
    }
  });

  const failed = results.filter((r) => !r.ok);
  const duration = Date.now() - startTime;

  // 获取默认下载目录路径
  const downloadPath = await getDefaultDownloadPath();

  if (failed.length > 0) {
    return {
      ok: false,
      error: "some_files_failed",
      results,
      folder,
      downloadPath,
      duration
    };
  }

  return {
    ok: true,
    folder,
    filesCount: results.length,
    results,
    downloadPath,
    duration
  };
}

// 获取默认下载目录路径
async function getDefaultDownloadPath() {
  try {
    // 尝试获取默认下载目录
    const downloadItems = await chrome.downloads.search({
      limit: 1,
      orderBy: ['-startTime']
    });

    if (downloadItems.length > 0 && downloadItems[0].filename) {
      const fullPath = downloadItems[0].filename;
      // 提取目录路径（去掉文件名）
      const pathParts = fullPath.split(/[/\\]/);
      pathParts.pop(); // 移除文件名
      return pathParts.join('/') || 'Downloads';
    }
  } catch (err) {
    console.warn('[UiToAi] 无法获取下载路径:', err);
  }

  // 返回默认路径
  return navigator.platform.includes('Win') ? 'Downloads' : 'Downloads';
}

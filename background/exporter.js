// ============================================================
// UiToAi - Exporter (Run -> folder files)
// ============================================================

function sanitizeFilename(s) {
  return String(s || "")
    .replace(/[\\/:*?"<>|]/g, "-")
    .replace(/\s+/g, "_")
    .slice(0, 60);
}

function t(key, substitutions) {
  try {
    const msg = chrome?.i18n?.getMessage?.(key, substitutions);
    return msg || "";
  } catch {
    return "";
  }
}

function generatePromptMd(spec, project) {
  const host = spec?.target?.host || project?.host || "unknown";
  const createdAt = spec?.target?.capturedAt || new Date().toISOString();

  const lines = [
    t("promptTitle", [host]) || `# Design System Extraction: ${host}`,
    "",
    t("promptGenerated", [createdAt]) || `> Generated by UiToAi at ${createdAt}`,
    "",
    t("promptInstructionsTitle") || "## Instructions for AI",
    "",
    t("promptInstructionsLine") || "Use this spec to replicate the design system. Follow this order:",
    "",
    t("promptStep1") || "1. **Design Tokens** - Set up colors, typography, spacing, shadows from `spec.designTokens`",
    t("promptStep2") || "2. **Layout** - Configure breakpoints and container widths from `spec.layoutRules`",
    t("promptStep3") || "3. **Motion** - Apply transition/animation timings from `spec.motionSpec`",
    t("promptStep4") || "4. **Accessibility** - Ensure focus rings and ARIA patterns from `spec.a11ySpec`",
    t("promptStep5") || "5. **Components** - Build components matching the catalog patterns",
    "",
    t("promptKeyValues") || "## Key Values",
    ""
  ];

  // Colors
  const colors = spec?.designTokens?.colors?.top || [];
  if (colors.length > 0) {
    lines.push("### Colors (Top " + colors.length + ")");
    colors.slice(0, 8).forEach((c) => {
      lines.push(`- \`${c.value}\` (${c.count} occurrences)`);
    });
    lines.push("");
  }

  // Typography
  const fonts = spec?.designTokens?.typography?.fontFamiliesTop || [];
  if (fonts.length > 0) {
    lines.push("### Font Families");
    fonts.slice(0, 5).forEach((f) => {
      lines.push(`- \`${f.value}\` (${f.count})`);
    });
    lines.push("");
  }

  // Breakpoints
  const breakpoints = spec?.layoutRules?.breakpoints?.candidates || [];
  if (breakpoints.length > 0) {
    lines.push("### Breakpoints");
    lines.push(`- ${breakpoints.join("px, ")}px`);
    lines.push("");
  }

  // Framework hints
  const fw = spec?.engineeringFingerprint?.frameworkHints || {};
  const detected = Object.entries(fw)
    .filter(([k, v]) => v && k !== "unknown")
    .map(([k]) => k);
  if (detected.length > 0) {
    lines.push("### Detected Frameworks");
    lines.push(`- ${detected.join(", ")}`);
    lines.push("");
  }

  // Motion
  const transitions = spec?.motionSpec?.transitions?.durationTop || [];
  if (transitions.length > 0) {
    lines.push("### Transition Durations");
    transitions.slice(0, 5).forEach((t) => {
      lines.push(`- \`${t.value}\` (${t.count})`);
    });
    lines.push("");
  }

  lines.push(t("promptFilesIncluded") || "## Files Included");
  lines.push("");
  lines.push(t("promptFileSpec") || "- `ai/spec.json` - Full specification data");
  lines.push(t("promptFilePrompt") || "- `ai/prompt.md` - This file");
  lines.push(t("promptFileSamples") || "- `samples/elements.json` - Captured element samples");
  lines.push("");
  lines.push("---");
  lines.push(t("promptFooter") || "*Use spec.json as the source of truth for all design decisions.*");

  return lines.join("\n");
}

async function downloadFile(folder, relativePath, content, mimeType) {
  // MV3 Service Worker 环境中 URL.createObjectURL 可能不可用。
  // 对于文本类导出（JSON/Markdown），用 data: URL 更稳定。
  const url = `data:${mimeType};charset=utf-8,${encodeURIComponent(String(content ?? ""))}`;

  try {
    // 所有文件都不弹出保存对话框，直接下载到默认下载目录
    await chrome.downloads.download({
      url,
      filename: `${folder}/${relativePath}`,
      saveAs: false // 统一不弹窗
    });
    return { ok: true, path: relativePath };
  } catch (err) {
    return { ok: false, path: relativePath, error: String(err?.message || err) };
  }
}

export async function exportRunToFiles(run, project) {
  const spec = run?.spec || {};
  const samples = run?.samples || { elements: [] };

  const host = sanitizeFilename(spec?.target?.host || project?.host || "unknown");
  const stamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
  const folder = `UiToAi-export-${host}-${stamp}`;

  const results = [];
  const startTime = Date.now();

  // 并行下载所有文件，提高效率
  const downloadPromises = [
    // 1. ai/spec.json
    downloadFile(
      folder,
      "ai/spec.json",
      JSON.stringify(spec, null, 2),
      "application/json"
    ),
    // 2. ai/prompt.md
    downloadFile(
      folder,
      "ai/prompt.md",
      generatePromptMd(spec, project),
      "text/markdown"
    ),
    // 3. samples/elements.json
    downloadFile(
      folder,
      "samples/elements.json",
      JSON.stringify(samples, null, 2),
      "application/json"
    )
  ];

  // 等待所有下载完成
  const downloadResults = await Promise.allSettled(downloadPromises);

  // 处理结果
  downloadResults.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      results.push(result.value);
    } else {
      const fileName = ['ai/spec.json', 'ai/prompt.md', 'samples/elements.json'][index];
      results.push({
        ok: false,
        path: fileName,
        error: String(result.reason?.message || result.reason)
      });
    }
  });

  const failed = results.filter((r) => !r.ok);
  const duration = Date.now() - startTime;

  // 获取默认下载目录路径
  const downloadPath = await getDefaultDownloadPath();

  if (failed.length > 0) {
    return {
      ok: false,
      error: "some_files_failed",
      results,
      folder,
      downloadPath,
      duration
    };
  }

  return {
    ok: true,
    folder,
    filesCount: results.length,
    results,
    downloadPath,
    duration
  };
}

// 获取默认下载目录路径
async function getDefaultDownloadPath() {
  try {
    // 尝试获取默认下载目录
    const downloadItems = await chrome.downloads.search({
      limit: 1,
      orderBy: ['-startTime']
    });

    if (downloadItems.length > 0 && downloadItems[0].filename) {
      const fullPath = downloadItems[0].filename;
      // 提取目录路径（去掉文件名）
      const pathParts = fullPath.split(/[/\\]/);
      pathParts.pop(); // 移除文件名
      return pathParts.join('/') || 'Downloads';
    }
  } catch (err) {
    console.warn('[UiToAi] 无法获取下载路径:', err);
  }

  // 返回默认路径
  return navigator.platform.includes('Win') ? 'Downloads' : 'Downloads';
}

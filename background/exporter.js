// ============================================================
// UiToAi - Exporter (Run -> folder files)
// ============================================================

function sanitizeFilename(s) {
  return String(s || "")
    .replace(/[\\/:*?"<>|]/g, "-")
    .replace(/\s+/g, "_")
    .slice(0, 60);
}

function t(key, substitutions) {
  try {
    const msg = chrome?.i18n?.getMessage?.(key, substitutions);
    return msg || "";
  } catch {
    return "";
  }
}

function generatePromptMd(spec, project) {
  const host = spec?.target?.host || project?.host || "unknown";
  const createdAt = spec?.target?.capturedAt || new Date().toISOString();

  const lines = [
    t("promptTitle", [host]) || `# Design System Extraction: ${host}`,
    "",
    t("promptGenerated", [createdAt]) || `> Generated by UiToAi at ${createdAt}`,
    "",
    t("promptInstructionsTitle") || "## Instructions for AI",
    "",
    t("promptInstructionsLine") || "Use this spec to replicate the design system. Follow this order:",
    "",
    t("promptStep1") || "1. **Design Tokens** - Set up colors, typography, spacing, shadows from `spec.designTokens`",
    t("promptStep2") || "2. **Layout** - Configure breakpoints and container widths from `spec.layoutRules`",
    t("promptStep3") || "3. **Motion** - Apply transition/animation timings from `spec.motionSpec`",
    t("promptStep4") || "4. **Accessibility** - Ensure focus rings and ARIA patterns from `spec.a11ySpec`",
    t("promptStep5") || "5. **Components** - Build components matching the catalog patterns",
    "",
    t("promptKeyValues") || "## Key Values",
    ""
  ];

  // Colors
  const colors = spec?.designTokens?.colors?.top || [];
  if (colors.length > 0) {
    lines.push("### Colors (Top " + colors.length + ")");
    colors.slice(0, 8).forEach((c) => {
      lines.push(`- \`${c.value}\` (${c.count} occurrences)`);
    });
    lines.push("");
  }

  // Typography
  const fonts = spec?.designTokens?.typography?.fontFamiliesTop || [];
  if (fonts.length > 0) {
    lines.push("### Font Families");
    fonts.slice(0, 5).forEach((f) => {
      lines.push(`- \`${f.value}\` (${f.count})`);
    });
    lines.push("");
  }

  // Breakpoints
  const breakpoints = spec?.layoutRules?.breakpoints?.candidates || [];
  if (breakpoints.length > 0) {
    lines.push("### Breakpoints");
    lines.push(`- ${breakpoints.join("px, ")}px`);
    lines.push("");
  }

  // Framework hints
  const fw = spec?.engineeringFingerprint?.frameworkHints || {};
  const detected = Object.entries(fw)
    .filter(([k, v]) => v && k !== "unknown")
    .map(([k]) => k);
  if (detected.length > 0) {
    lines.push("### Detected Frameworks");
    lines.push(`- ${detected.join(", ")}`);
    lines.push("");
  }

  // Motion
  const transitions = spec?.motionSpec?.transitions?.durationTop || [];
  if (transitions.length > 0) {
    lines.push("### Transition Durations");
    transitions.slice(0, 5).forEach((t) => {
      lines.push(`- \`${t.value}\` (${t.count})`);
    });
    lines.push("");
  }

  lines.push(t("promptFilesIncluded") || "## Files Included");
  lines.push("");
  lines.push(t("promptFileSpec") || "- `ai/spec.json` - Full specification data");
  lines.push(t("promptFilePrompt") || "- `ai/prompt.md` - This file");
  lines.push(t("promptFileSamples") || "- `samples/elements.json` - Captured element samples");
  lines.push("");
  lines.push("---");
  lines.push(t("promptFooter") || "*Use spec.json as the source of truth for all design decisions.*");

  return lines.join("\n");
}

async function downloadFile(folder, relativePath, content, mimeType, isFirst = false) {
  // MV3 Service Worker 环境中 URL.createObjectURL 可能不可用。
  // 对于文本类导出（JSON/Markdown），用 data: URL 更稳定。
  const url = `data:${mimeType};charset=utf-8,${encodeURIComponent(String(content ?? ""))}`;

  try {
    await chrome.downloads.download({
      url,
      filename: `${folder}/${relativePath}`,
      saveAs: isFirst // 只有第一个文件弹出保存对话框
    });
    return { ok: true, path: relativePath };
  } catch (err) {
    return { ok: false, path: relativePath, error: String(err?.message || err) };
  }
}

export async function exportRunToFiles(run, project) {
  const spec = run?.spec || {};
  const samples = run?.samples || { elements: [] };

  const host = sanitizeFilename(spec?.target?.host || project?.host || "unknown");
  const stamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
  const folder = `UiToAi-export-${host}-${stamp}`;

  const results = [];

  // 1. ai/spec.json（第一个文件，saveAs=true 让用户选择下载位置）
  results.push(await downloadFile(
    folder,
    "ai/spec.json",
    JSON.stringify(spec, null, 2),
    "application/json",
    true
  ));

  // 短暂延迟，避免浏览器阻止批量下载
  await new Promise((r) => setTimeout(r, 300));

  // 2. ai/prompt.md
  results.push(await downloadFile(
    folder,
    "ai/prompt.md",
    generatePromptMd(spec, project),
    "text/markdown",
    false
  ));

  await new Promise((r) => setTimeout(r, 200));

  // 3. samples/elements.json
  results.push(await downloadFile(
    folder,
    "samples/elements.json",
    JSON.stringify(samples, null, 2),
    "application/json",
    false
  ));

  const failed = results.filter((r) => !r.ok);
  if (failed.length > 0) {
    return { ok: false, error: "some_files_failed", results };
  }

  return { ok: true, folder, filesCount: results.length, results };
}
